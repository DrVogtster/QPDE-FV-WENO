# -*- coding: utf-8 -*-
"""ConvertFunctionsToJax.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19Ptq1ZnSVhD_wDkdPet_HYd-PQZbPedO
"""

import numpy as np
import jax
import jax.numpy as jnp
from functools import partial
from scipy.integrate import quad_vec
from scipy.optimize import fsolve
jax.config.update("jax_enable_x64", True)
# Common parameters
gam = 1.4  # 1.4 (heat capacity ratio for diatomic ideal gas ~ standard air)

# Nx_test = 1024
# u_test = np.random.rand(3,Nx_test) + 1

def reconstructWENO(uim2, uim1, ui, uip1, uip2):
    # polynomial approx
    up051 = (2*uim2 - 7*uim1 + 11*ui )/6
    up052 = ( -uim1 + 5*ui   + 2*uip1)/6
    up053 = (2*ui   + 5*uip1 -   uip2)/6
    # smoothness indicators
    b1 = 13/12*(uim2 - 2*uim1 + ui  )**2 + 0.25*(uim2 - 4*uim1 + 3*ui)**2
    b2 = 13/12*(uim1 - 2*ui   + uip1)**2 + 0.25*(uim1 - uip1)**2
    b3 = 13/12*(ui   - 2*uip1 + uip2)**2 + 0.25*(3*ui - 4*uip1 + uip2)**2
    # weights
    w1 = 0.1 / (1e-6 + b1)**2
    w2 = 0.6 / (1e-6 + b2)**2
    w3 = 0.3 / (1e-6 + b3)**2
    ws = w1 + w2 + w3
    # reconstructed cell-interface value
    up05m = (w1*up051 + w2*up052 + w3*up053)/ws
    return up05m

@partial(jax.jit)
def reconstructWENO_vec(x):
    # uim2, uim1, ui, uip1, uip2
    # x[0], x[1], x[2], x[3], x[4]
    # polynomial approx
    up051 = (2*x[:,0] - 7*x[:,1] + 11*x[:,2] )/6
    up052 = ( -x[:,1] + 5*x[:,2]   + 2*x[:,3])/6
    up053 = (2*x[:,2]   + 5*x[:,3] -   x[:,4])/6
    # smoothness indicators
    b1 = 13/12*(x[:,0] - 2*x[:,1] + x[:,2]  )**2 + 0.25*(x[:,0] - 4*x[:,1] + 3*x[:,2])**2
    b2 = 13/12*(x[:,1] - 2*x[:,2]   + x[:,3])**2 + 0.25*(x[:,1] - x[:,3])**2
    b3 = 13/12*(x[:,2]   - 2*x[:,3] + x[:,4])**2 + 0.25*(3*x[:,2] - 4*x[:,3] + x[:,4])**2
    # weights
    w1 = 0.1 / (1e-6 + b1)**2
    w2 = 0.6 / (1e-6 + b2)**2
    w3 = 0.3 / (1e-6 + b3)**2
    ws = w1 + w2 + w3
    # reconstructed cell-interface value
    up05m = (w1*up051 + w2*up052 + w3*up053)/ws
    return up05m

@partial(jax.jit)
def Roe(u, up1):
    sRhoL = jnp.sqrt(u[0])
    sRhoR = jnp.sqrt(up1[0])
    vL = u[1] / u[0]
    vR = up1[1] / up1[0]
    v = (sRhoL * vL + sRhoR * vR) / (sRhoL + sRhoR)
    pL = (gam - 1) * (u[2] - 0.5 * u[0] * vL**2)
    pR = (gam - 1) * (up1[2] - 0.5 * up1[0] * vR**2)
    aL = jnp.sqrt(gam * pL / u[0])
    aR = jnp.sqrt(gam * pR / up1[0])
    HL = 0.5 * vL**2 + aL**2 / (gam - 1)
    HR = 0.5 * vR**2 + aR**2 / (gam - 1)
    H = (sRhoL * HL + sRhoR * HR) / (sRhoL + sRhoR)
    h = H - 0.5 * v**2
    a = jnp.sqrt((gam - 1) * h)
    vecsR = jnp.array([1, 1, 1, v - a, v, v + a, H - v * a, 0.5 * v**2, H + v * a]) #shape (9,)
    vecsL = 0.5 / h * jnp.array([0.5 * v**2 + v * h / a, -h / a - v, 1, 2 * h - v**2, 2 * v, -2, 0.5 * v**2 - v * h / a, h / a - v, 1]) #shape (9,)
    P = jnp.reshape(vecsR, (3, 3))
    Pm = jnp.reshape(vecsL, (3, 3))
    return P, Pm

def Roe_og(u, up1):
    sRhoL = np.sqrt(u[0])
    sRhoR = np.sqrt(up1[0])
    vL = u[1] / u[0]
    vR = up1[1] / up1[0]
    v = (sRhoL * vL + sRhoR * vR) / (sRhoL + sRhoR)
    pL = (gam - 1) * (u[2] - 0.5 * u[0] * vL**2)
    pR = (gam - 1) * (up1[2] - 0.5 * up1[0] * vR**2)
    aL = np.sqrt(gam * pL / u[0])
    aR = np.sqrt(gam * pR / up1[0])
    HL = 0.5 * vL**2 + aL**2 / (gam - 1)
    HR = 0.5 * vR**2 + aR**2 / (gam - 1)
    H = (sRhoL * HL + sRhoR * HR) / (sRhoL + sRhoR)
    h = H - 0.5 * v**2
    a = np.sqrt((gam - 1) * h)
    vecsR = np.array([1, 1, 1, v - a, v, v + a, H - v * a, 0.5 * v**2, H + v * a]) #shape (9,)
    vecsL = 0.5 / h * np.array([0.5 * v**2 + v * h / a, -h / a - v, 1, 2 * h - v**2, 2 * v, -2, 0.5 * v**2 - v * h / a, h / a - v, 1]) #shape (9,)
    P = np.reshape(vecsR, (3, 3))
    Pm = np.reshape(vecsL, (3, 3))
    return P, Pm

def WENO_Roe_og(u):
    Nx = u.shape[-1] #Nx = len(u[0,:])
    # print(Nx)
    up05m = u.copy()
    up05p = np.roll(u, -1, axis=1)
    w = u.copy()
    for j in range(2, Nx - 3):
        # Roe average
        P, Pm = Roe_og(u[:, j], u[:, j + 1])
        # local characteristic variables
        for k in range(j - 2, j + 4):
            w[:, k] = np.dot(Pm, u[:, k])
        wp05m = w[:, j].copy()
        wp05p = w[:, j + 1].copy()
        for i in range(3):
            wp05m[i] = reconstructWENO(w[i, j - 2], w[i, j - 1], w[i, j], w[i, j + 1], w[i, j + 2])
            wp05p[i] = reconstructWENO(w[i, j + 3], w[i, j + 2], w[i, j + 1], w[i, j], w[i, j - 1])
        up05m[:, j] = np.dot(P, wp05m)
        up05p[:, j] = np.dot(P, wp05p)
    return up05m, up05p

# def WENO_Roe(u):
#     Nx = len(u[0,:])
#     up05m = jnp.copy(u)
#     up05p = jnp.roll(u, -1, axis=1)
#     w = jnp.copy(u)
#     for j in range(2, Nx - 3):
#         # Roe average
#         P, Pm = Roe(u[:, j], u[:, j + 1])
#         # local characteristic variables
#         for k in range(j - 2, j + 4):
#             w.at[:, k].set(jnp.dot(Pm, u[:, k]))
#         wp05m = jnp.copy(w[:, j])
#         wp05p = jnp.copy(w[:, j+1])
#         for i in range(3):
#             wp05m.at[i].set(reconstructWENO(w[i, j - 2], w[i, j - 1], w[i, j], w[i, j + 1], w[i, j + 2]))
#             wp05p.at[i].set(reconstructWENO(w[i, j + 3], w[i, j + 2], w[i, j + 1], w[i, j], w[i, j - 1]))
#         up05m.at[:, j].set( jnp.dot(P, wp05m))
#         up05p.at[:, j].set( jnp.dot(P, wp05p))
#     return up05m, up05p

def WENO_Roe(u):
  Nx = u.shape[-1] #Nx = len(u[0,:])

  Ps, Pms = jax.vmap(lambda a, b: Roe(a, b), in_axes=1)(u[:,0:-2],u[:,1:-1]) #(Nx-3, 3, 3)

  @partial(jax.jit)
  def computeWsub(j):
    # u_sub = u[:,j-2:j+4]
    u_sub = jax.lax.dynamic_slice(u, (0,j-2), (u.shape[0],6))
    # # local characteristic variables
    # w_sub = jnp.dot(Pm, u_sub) #(3, 6) 
    w_sub = jnp.dot(Pms[j,:,:], u_sub)
    return w_sub
    
  w_subs = jax.vmap(computeWsub)(jnp.arange(2, Nx - 3))#(Nx-5, 3, 6)

  #P has extra rows at the front & back we need to slice out when we build these 
  up05ms = jax.vmap(lambda P, w_sub: jnp.dot(P, reconstructWENO_vec(w_sub[:, 0:5])) )(Ps[2:-1,:,:], w_subs)
  up05ps = jax.vmap(lambda P, w_sub: jnp.dot(P, reconstructWENO_vec(jnp.flip(w_sub[:, 1:6], axis=-1))) )(Ps[2:-1,:,:], w_subs) #The fix is here, the axis=-1 was needed

  #The first 2 and last 3 rows of up05m come from the original u
  up05ms = jnp.vstack([u[:,:2].T, up05ms, u[:,-3:].T])
  #up05p has a roll, so the first 2 rows from from the 2nd and 3rd of OG u, the first OG u becomes the last, etc. 
  up05ps = jnp.vstack([u[:,1:3].T, up05ps, u[:,-2:].T,u[:,:1].T])

  #OOPS I built the same results transposed, lets flip them back k-thnx-bye 
  return up05ms.T, up05ps.T

# u_test[0,1:5]

# WENO_Roe(u_test)

# WENO_Roe(u_test)

# WENO_Roe(u_test)

# ----------------------------------------------------------------
# Boundary conditions
# ----------------------------------------------------------------

def PeriodicBC_og(u):
    Nx = len(u[0,:])
    v = u
    v[:,0] = u[:,Nx-6]
    v[:,1] = u[:,Nx-5]
    v[:,2] = u[:,Nx-4]
    v[:,Nx-3] = u[:,3]
    v[:,Nx-2] = u[:,4]
    v[:,Nx-1] = u[:,5]
    return v

# @jax.jit
# def PeriodicBC(u):
#     Nx = u.shape[1]
#     v = jnp.copy(u)
#     v.at[:,0].set(u[:,Nx-6])
#     v.at[:,1].set(u[:,Nx-5])
#     v.at[:,2].set(u[:,Nx-4])
#     v.at[:,Nx-3].set(u[:,3])
#     v.at[:,Nx-2].set(u[:,4])
#     v.at[:,Nx-1].set(u[:,5])
#     return v

def OutgoingBC_og(u):
    Nx = len(u[0,:])
    v = u
    v[:,0] = u[:,3]
    v[:,1] = u[:,3]
    v[:,2] = u[:,3]
    v[:,Nx-3] = u[:,Nx-4]
    v[:,Nx-2] = u[:,Nx-4]
    v[:,Nx-1] = u[:,Nx-4]
    return v

# @jax.jit
# def OutgoingBC(u):
#     Nx = u.shape[1]
#     v = jnp.copy(u)
#     v.at[:,0].set(u[:,3])
#     v.at[:,1].set(u[:,3])
#     v.at[:,2].set(u[:,3])
#     v.at[:,Nx-3].set(u[:,Nx-4])
#     v.at[:,Nx-2].set(u[:,Nx-4])
#     v.at[:,Nx-1].set(u[:,Nx-4])
#     return v
@jax.jit
def PeriodicBC(u):
    Nx = u.shape[1]
    #PeriodBC first new Front
    front = u[:,Nx-6:Nx-3]
    #PeriodBC back end
    back = u[:,3:6]
    #PeriodBX middle
    middle = u[:,3:Nx-3]

    return jnp.hstack([front, middle, back])

@jax.jit
def OutgoingBC(u):
    Nx = u.shape[1]
    back = u[:,Nx-4:Nx-3]
    front = u[:,3:4]
    middle = u[:,3:Nx-3]
    
    return jnp.hstack([front, front, front, middle, back, back, back])
# OutgoingBC_og(u_test)- OutgoingBC(u_test)

@partial(jax.jit)
def f(u):
    v = u[1,:] / u[0,:]
    flx = jnp.array([u[1,:], 0.5*(3-gam)*u[0,:]*v**2 + (gam-1)*u[2,:], gam*u[2,:]*v - 0.5*(gam-1)*u[0,:]*v**3])
    return flx

def EigA_og(u):
    v = u[1,:] / u[0,:]
    p = (gam-1) * (u[2,:] - 0.5*u[0,:]*v**2)
    a = np.sqrt(gam*p/u[0,:])
    vals = np.array([v-a, v, v+a])
    H = 0.5*v**2 + a**2/(gam-1)
    N = len(u[0,:])
    vecs = np.array([[1]*N, v-a, H-v*a,
                     [1]*N, v, 0.5*v**2,
                     [1]*N, v+a, H+v*a])
    return vals, vecs

@partial(jax.jit)
def EigA(u):
    v = u[1,:] / u[0,:]
    p = (gam-1) * (u[2,:] - 0.5*u[0,:]*v**2)
    a = jnp.sqrt(gam*p/u[0,:])
    vals = jnp.array([v-a, v, v+a])
    H = 0.5*v**2 + a**2/(gam-1)
    N = len(u[0,:])
    vecs = jnp.array([[1]*N, v-a, H-v*a,
                     [1]*N, v, 0.5*v**2,
                     [1]*N, v+a, H+v*a])
    return vals, vecs

def LxF_og(u, inter): # LLF flux
    up05m, up05p = inter(u)
    vals, _ = EigA_og(u)
    amax = np.max(np.abs(vals[2,:] - vals[1,:]) + np.abs(vals[1,:]))
    fp05 = 0.5 * (f(up05m) + f(up05p) - amax * (up05p - up05m))
    return fp05

@partial(jax.jit, static_argnums=(1,))
def LxF(u, inter): # LLF flux
    up05m, up05p = inter(u)
    vals, _ = EigA(u)
    amax = jnp.max(jnp.abs(vals[2,:] - vals[1,:]) + jnp.abs(vals[1,:]))
    fp05 = 0.5 * (f(up05m) + f(up05p) - amax * (up05p - up05m))
    return fp05

def RHS(flux, inter, BC, dx):
    @partial(jax.jit)
    def my_func(u):
        u=BC(u)

        fp05 = flux(u, inter)
        fm05 = jnp.roll(fp05, 1, axis=1)
        flx = -(fp05 - fm05)/dx
        flx = BC(flx)
        df = flx
        return df
    return my_func

# rhs = RHS(LxF, WENO_Roe, PeriodicBC, 0.5)

# Commented out IPython magic to ensure Python compatibility.
# %timeit rhs(u_test)

# Commented out IPython magic to ensure Python compatibility.
# %timeit RHS(LxF, WENO_Roe_og, PeriodicBC_og, 0.5)(u_test)



def Density():
    def my_func(x):
        rho = 1 + 0.2*np.sin(np.pi*x)
        if isinstance(x, float):
            u = 1
            p = 1
        else:
            Nx = len(x)
            u = np.ones(Nx)
            p = np.ones(Nx)
        u0 = np.array([rho, rho*u, 0.5*rho*u**2 + p/(gam-1)])
        return u0
    return my_func, 'Density'

def Riemann(rhoJ,uJ,pJ):
    # Initial data
    UJ = np.array([rhoJ, rhoJ*uJ, 0.5*rhoJ*uJ**2 + pJ/(gam-1)])
    def my_func(x):
        if isinstance(x, float):
            u0 = UJ[:,0]*(x<0) + UJ[:,1]*(x>=0)
        else:
            Nx = len(x)
            u0 = np.zeros((3,Nx))
            for i in range(Nx):
                if x[i]<0:
                    u0[:,i] = UJ[:,0]
                else:
                    u0[:,i] = UJ[:,1]
        return u0
    return my_func, 'Riemann'

def cellav(u0, x, dx):
    u = u0(x)
    uav0 = lambda x: quad_vec(u0, x-0.5*dx, x+0.5*dx)[0] / dx
    for i in range(len(x)):
        u[:,i] = uav0(x[i])
    return u

def DoNone(u):
    up05m = u
    up05p = np.roll(u, -1, axis=1)
    return up05m, up05p


def RiemannExact(UJ, gam, t):
    # Initial function arguments
    rhoL = UJ[0,0]
    rhouL = UJ[1,0]
    EL = UJ[2,0]
    rhoR = UJ[0,1]
    rhouR = UJ[1,1]
    ER = UJ[2,1]
    uL = rhouL/rhoL
    pL = (gam-1)*(EL - 0.5*rhouL*uL)
    uR = rhouR/rhoR
    pR = (gam-1)*(ER - 0.5*rhouR*uR)
    
    # useful quantities (cf. Toro p. 119)
    aL = np.sqrt(gam*pL/rhoL)
    aR = np.sqrt(gam*pR/rhoR)
    AL = 2/((gam+1)*rhoL)
    AR = 2/((gam+1)*rhoR)
    BL = (gam-1)/(gam+1)*pL
    BR = (gam-1)/(gam+1)*pR
    du = uR - uL
    
    def fL(p):
        return (p-pL)*np.sqrt(AL/(p+BL))*(p>pL) + 2*aL/(gam-1)*((p/pL)**((gam-1)/(2*gam)) - 1)*(p<=pL)
    
    def fR(p):
        return (p-pR)*np.sqrt(AR/(p+BR))*(p>pR) + 2*aR/(gam-1)*((p/pR)**((gam-1)/(2*gam)) - 1)*(p<=pR)
    
    def f(p):
        return fL(p) + fR(p) + du
    
    # Solution output
    if uR-uL > 2*(aL+aR)/(gam-1):
        print('Warning: Vacuum is created, i.e., pressure positivity is violated!')
        us = 0
        rholeft = lambda x: 0
        uleft = lambda x: 0
        pleft = lambda x: 0
        rhoright = lambda x: 0
        uright = lambda x: 0
        pright = lambda x: 0
    else:
        # star region
        p0 = max([np.finfo(float).eps, 0.5*(pL+pR)- du*(rhoL+rhoR)*(aL+aR)/8])
        ps = fsolve(f, p0)
        us = 0.5*(uR+uL) + 0.5*(fR(ps)-fL(ps))
        # solution types
        if ps>pL:
            # print('Left-going shock')
            rhoLs = rhoL * ( (gam-1)/(gam+1) + ps/pL )/( (gam-1)/(gam+1)*ps/pL + 1 )
            S1 = uL - aL*np.sqrt( (gam+1)/(2*gam)*ps/pL + (gam-1)/(2*gam) )
            rholeft = lambda x: rhoL*(x<S1*t) + rhoLs*(x>=S1*t)
            uleft = lambda x: uL*(x<S1*t) + us*(x>=S1*t)
            pleft = lambda x: pL*(x<S1*t) + ps*(x>=S1*t)
        else:
            # print('Left-going rarefaction')
            aLs = aL + (uL-us)*(gam-1)/2
            rhoLs = gam*ps/aLs**2
            rholeft = lambda x: rhoL*(x<(uL-aL)*t) + rhoLs*(x>=(us-aLs)*t) + rhoL*np.abs(2/(gam+1) + (gam-1)/((gam+1)*aL)*(uL-x/t))**(2/(gam-1))*(x>=(uL-aL)*t)*(x<(us-aLs)*t)
            uleft = lambda x: uL*(x<(uL-aL)*t) + us*(x>=(us-aLs)*t) + 2/(gam+1)*(aL + (gam-1)/2*uL + x/t)*(x>=(uL-aL)*t)*(x<(us-aLs)*t)
            pleft = lambda x: pL*(x<(uL-aL)*t) + ps*(x>=(us-aLs)*t) + pL*np.abs(2/(gam+1) + (gam-1)/((gam+1)*aL)*(uL-x/t))**(2*gam/(gam-1))*(x>=(uL-aL)*t)*(x<(us-aLs)*t)
        if ps>pR:
            # print('Right-going shock')
            rhoRs = rhoR * ( (gam-1)/(gam+1) + ps/pR )/( (gam-1)/(gam+1)*ps/pR + 1 )
            S3 = uR + aR*np.sqrt( (gam+1)/(2*gam)*ps/pR + (gam-1)/(2*gam) )
            rhoright = lambda x: rhoR*(x>S3*t) + rhoRs*(x<=S3*t)
            uright = lambda x: uR*(x>S3*t) + us*(x<=S3*t)
            pright = lambda x: pR*(x>S3*t) + ps*(x<=S3*t)
        else:
            # print('Right-going rarefaction')
            aRs = aR + (us-uR)*(gam-1)/2
            rhoRs = gam*ps/aRs**2
            rhoright = lambda x: rhoR*(x>(uR+aR)*t) + rhoRs*(x<=(us+aRs)*t) + rhoR*np.abs(2/(gam+1) - (gam-1)/((gam+1)*aR)*(uR-x/t))**(2/(gam-1))*(x<=(uR+aR)*t)*(x>(us+aRs)*t)
            uright = lambda x: uR*(x>(uR+aR)*t) + us*(x<=(us+aRs)*t) + 2/(gam+1)*(-aR + (gam-1)/2*uR + x/t)*(x<=(uR+aR)*t)*(x>(us+aRs)*t)
            pright = lambda x: pR*(x>(uR+aR)*t) + ps*(x<=(us+aRs)*t) + pR*np.abs(2/(gam+1) - (gam-1)/((gam+1)*aR)*(uR-x/t))**(2*gam/(gam-1))*(x<=(uR+aR)*t)*(x>(us+aRs)*t)
    
    def sol(x):
        if isinstance(x, float):
            UL = np.array([rholeft(x), rholeft(x)*uleft(x), 0.5*rholeft(x)*uleft(x)**2 + pleft(x)/(gam-1)])
            UR = np.array([rhoright(x), rhoright(x)*uright(x), 0.5*rhoright(x)*uright(x)**2 + pright(x)/(gam-1)])
            u = UL[:,0]*(x<us*t) + UR[:,0]*(x>=us*t)
        else:
            Nx = len(x)
            u = np.zeros((3,Nx))
            for i in range(Nx):
                UL = np.array([rholeft(x[i]), rholeft(x[i])*uleft(x[i]), 0.5*rholeft(x[i])*uleft(x[i])**2 + pleft(x[i])/(gam-1)])
                UR = np.array([rhoright(x[i]), rhoright(x[i])*uright(x[i]), 0.5*rhoright(x[i])*uright(x[i])**2 + pright(x[i])/(gam-1)])
                u[:,i] = UL[:,0]*(x[i]<us*t) + UR[:,0]*(x[i]>=us*t)
        return u
    
    return sol